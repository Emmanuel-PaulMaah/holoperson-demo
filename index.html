<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR AR â€¢ RPM + Mixamo autoplay</title>
  <link rel="icon" href="data:,"><!-- kill favicon 404 -->

  <!-- map bare specifier "three" to the CDN module -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin:0; height:100%; background:#000; }
    #enter-ar { position:fixed; left:12px; bottom:12px; z-index:10; }
    .hint { position:fixed; left:12px; top:12px; color:#fff; font:14px/1.4 system-ui, sans-serif; }
  </style>
</head>
<body>
<div class="hint">Auto-place on first plane. Animations loop.</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';

const AVATAR_URL = './assets/model_avatar.glb';
const ANIM_URLS = [
  './assets/Talking1.glb',
  './assets/Talking2.glb',
  './assets/Talking3.glb',
  './assets/Breathing_Idle.glb'
];

// renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.xr.enabled = true;
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera();
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));

// reticle
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.1,0.12,48).rotateX(-Math.PI/2),
  new THREE.MeshBasicMaterial({ color:0xff7a00 })
);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// button
document.body.appendChild(ARButton.createButton(renderer,{
  requiredFeatures:['hit-test'],
  optionalFeatures:['dom-overlay','anchors'],
  domOverlay:{ root: document.body }
}));

// loaders
const gltf = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
gltf.setDRACOLoader(draco);

// avatar + anims
let avatar, mixer, outline;
let clips=[];
let placed=false;
await gltf.loadAsync(AVATAR_URL).then(g=>{avatar=g.scene;scene.add(avatar);avatar.visible=false;mixer=new THREE.AnimationMixer(avatar);outline=new THREE.BoxHelper(avatar,0xff7a00);outline.visible=false;scene.add(outline);});
await Promise.all(ANIM_URLS.map(u=>gltf.loadAsync(u).then(g=>{if(g.animations?.length)clips.push(g.animations[0]);})));
function playNext(){
  const clip=clips.shift();clips.push(clip);
  const a=mixer.clipAction(clip);mixer.stopAllAction();a.reset().play();
}

// XR vars
let viewerSpace, localSpace, planeSource, fingerSource;
let touches=[]; // transient hit test data
let lastDist, lastAngle, baseScale=1, baseRotY=0;

renderer.xr.addEventListener('sessionstart',async()=>{
  const s=renderer.xr.getSession();
  viewerSpace=await s.requestReferenceSpace('viewer');
  localSpace=await s.requestReferenceSpace('local');
  planeSource=await s.requestHitTestSource({space:viewerSpace});
  fingerSource=await s.requestHitTestSourceForTransientInput({profile:'generic-touchscreen'});
});
renderer.xr.addEventListener('sessionend',()=>{
  viewerSpace=localSpace=planeSource=fingerSource=null;
  placed=false;
});

const clock=new THREE.Clock();
renderer.setAnimationLoop((_,frame)=>{
  const dt=clock.getDelta();
  mixer?.update(dt);

  if(frame && planeSource && !placed){
    const hits=frame.getHitTestResults(planeSource);
    if(hits.length){
      const pose=hits[0].getPose(localSpace);
      reticle.visible=true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else reticle.visible=false;
  }

  if(frame && fingerSource){
    const fingers=frame.getHitTestResultsForTransientInput(fingerSource);
    if(fingers.length){
      // show outline while finger(s) active
      outline.visible=true;
      if(!placed && reticle.visible) place(reticle.matrix);
      if(placed){
        if(fingers.length===1 && fingers[0].results.length){
          // single finger drag
          const pose=fingers[0].results[0].getPose(localSpace);
          const m=new THREE.Matrix4().fromArray(pose.transform.matrix);
          const pos=new THREE.Vector3().setFromMatrixPosition(m);
          avatar.position.set(pos.x, avatar.position.y, pos.z);
        } else if(fingers.length===2 && fingers[0].results.length && fingers[1].results.length){
          // rotate/scale
          const p1=new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(fingers[0].results[0].getPose(localSpace).transform.matrix));
          const p2=new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(fingers[1].results[0].getPose(localSpace).transform.matrix));
          const v1=new THREE.Vector2(p1.x,p1.z);
          const v2=new THREE.Vector2(p2.x,p2.z);
          const dist=v1.distanceTo(v2);
          const angle=Math.atan2(v2.y-v1.y,v2.x-v1.x);
          if(lastDist===undefined){lastDist=dist;lastAngle=angle;baseScale=avatar.scale.x;baseRotY=avatar.rotation.y;}
          const s=THREE.MathUtils.clamp(baseScale*(dist/lastDist),0.2,3);
          avatar.scale.setScalar(s);
          avatar.rotation.y=baseRotY+(angle-lastAngle);
        }
      }
    } else {outline.visible=false; lastDist=undefined;}
  }

  renderer.render(scene,camera);
});

function place(m){
  avatar.visible=true;
  avatar.position.setFromMatrixPosition(m);
  const cam=renderer.xr.getCamera(camera);
  avatar.lookAt(new THREE.Vector3(cam.position.x,avatar.position.y,cam.position.z));
  placed=true;
  reticle.visible=false;
  playNext();
}
</script>

</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR AR â€¢ RPM + Mixamo autoplay</title>
  <link rel="icon" href="data:,">

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin:0; height:100%; background:#000; }
    #reset { position:fixed; left:12px; bottom:12px; z-index:10; }
    .hint { position:fixed; left:12px; top:12px; color:#fff; font:14px/1.4 system-ui, sans-serif; }
  </style>
</head>
<body>
<div class="hint">Auto-place on first plane. Animations cross-fade and cycle.</div>
<button id="reset">Reset</button>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';
import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';

const AVATAR_URL = './assets/model_avatar.glb';
const ANIM_URLS = [
  './assets/Talking1.glb',
  './assets/Talking2.glb',
  './assets/Talking3.glb',
  './assets/Breathing_Idle.glb'
];

// renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.xr.enabled = true;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera();

// lighting: IBL + hemi + key
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.5).texture;

const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
scene.add(hemi);

const key = new THREE.DirectionalLight(0xffffff, 0.8);
key.position.set(1, 2, 1);
scene.add(key);

// reticle
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.1,0.12,48).rotateX(-Math.PI/2),
  new THREE.MeshBasicMaterial({ color:0xff7a00 })
);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// button
document.body.appendChild(ARButton.createButton(renderer,{
  requiredFeatures:['hit-test'],
  optionalFeatures:['dom-overlay','anchors'],
  domOverlay:{ root: document.body }
}));

// loaders
const gltf = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
gltf.setDRACOLoader(draco);

// avatar + anims
let avatar, mixer, outline;
let clips = [];
let placed = false;
let currentAction = null;

// error-safe GLB load
async function loadGLB(url){
  try {
    return await gltf.loadAsync(url);
  } catch (e) {
    console.error('GLB load failed', url, e);
    return { scene: new THREE.Group(), animations: [] };
  }
}

const avatarG = await loadGLB(AVATAR_URL);
avatar = avatarG.scene;
scene.add(avatar);
avatar.visible = false;

mixer = new THREE.AnimationMixer(avatar);

outline = new THREE.BoxHelper(avatar, 0xff7a00);
outline.matrixAutoUpdate = false;
outline.visible = false;
scene.add(outline);

await Promise.all(ANIM_URLS.map(async u=>{
  const g = await loadGLB(u);
  if (g.animations?.length) clips.push(g.animations[0]);
}));

function playNext(fade=0.3){
  if (!clips.length) return;
  const clip = clips.shift(); clips.push(clip);
  const next = mixer.clipAction(clip);
  next.reset().setLoop(THREE.LoopOnce, 0);
  next.clampWhenFinished = true;
  if (currentAction) {
    currentAction.crossFadeTo(next, fade, false);
  }
  next.play();
  currentAction = next;
}
mixer.addEventListener('finished', () => playNext());

// XR vars
let viewerSpace, localSpace, planeSource, fingerSource;
let lastHit = null;       // last plane hit result for anchoring
let anchor = null;        // XRAnchor handle

let lastDist, lastAngle, baseScale=1, baseRotY=0;
let fingersActive = 0;

renderer.xr.addEventListener('sessionstart', async ()=>{
  const s = renderer.xr.getSession();
  viewerSpace = await s.requestReferenceSpace('viewer');
  localSpace  = await s.requestReferenceSpace('local');
  planeSource = await s.requestHitTestSource({ space: viewerSpace });
  fingerSource = await s.requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' });
});

renderer.xr.addEventListener('sessionend', ()=>{
  viewerSpace = localSpace = planeSource = fingerSource = null;
  lastHit = null;
  placed = false;
  lastDist = undefined;
  fingersActive = 0;
  outline.visible = false;
  if (anchor?.delete) { try { anchor.delete(); } catch {} }
  anchor = null;
  // keep avatar loaded but hidden for next session
  avatar.visible = false;
  currentAction = null;
  mixer.stopAllAction();
});

// resize
addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); });

const clock = new THREE.Clock();

// stable auto-place state
let stableCount = 0;
const lastPoseMat = new THREE.Matrix4();

renderer.setAnimationLoop((_, frame)=>{
  const dt = clock.getDelta();
  mixer?.update(dt);

  // anchor pose update
  if (frame && anchor?.anchorSpace && localSpace && avatar.visible) {
    const ap = frame.getPose(anchor.anchorSpace, localSpace);
    if (ap) {
      avatar.matrix.fromArray(ap.transform.matrix);
      avatar.matrix.decompose(avatar.position, avatar.quaternion, avatar.scale);
    }
  }

  // reticle + auto-place
  if (frame && planeSource && !placed){
    const hits = frame.getHitTestResults(planeSource);
    if (hits.length){
      const hit = hits[0];
      const pose = hit.getPose(localSpace);
      if (pose){
        const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
        reticle.visible = true;
        reticle.matrix.copy(m);
        if (lastPoseMat.equals(m)) stableCount++; else { stableCount = 0; lastPoseMat.copy(m); }
        lastHit = hit;
        if (stableCount > 15) place(reticle.matrix, lastHit, frame);
      }
    } else {
      reticle.visible = false;
      stableCount = 0;
      lastHit = null;
    }
  }

  // gestures
  if (frame && fingerSource){
    const fingers = frame.getHitTestResultsForTransientInput(fingerSource);
    if (fingers.length){
      outline.visible = true;

      if (!placed && reticle.visible) place(reticle.matrix, lastHit, frame);

      if (placed){
        const got = fingers.filter(f=>f.results?.length).slice(0,2);
        if (fingersActive !== got.length) {
          lastDist = undefined;
        }
        fingersActive = got.length;

        if (got.length === 1){
          const r = got[0].results[0];
          const pose = r.getPose(localSpace);
          if (pose){
            const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
            const pos = new THREE.Vector3().setFromMatrixPosition(m);
            avatar.position.set(pos.x, avatar.position.y, pos.z);
          }
        } else if (got.length === 2){
          const [r1, r2] = got.map(f=>f.results[0]);
          const p1 = new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(r1.getPose(localSpace).transform.matrix));
          const p2 = new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(r2.getPose(localSpace).transform.matrix));
          const v1 = new THREE.Vector2(p1.x, p1.z);
          const v2 = new THREE.Vector2(p2.x, p2.z);
          const dist = Math.max(1e-4, v1.distanceTo(v2));
          const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);
          if (lastDist === undefined){ lastDist = dist; lastAngle = angle; baseScale = avatar.scale.x; baseRotY = avatar.rotation.y; }
          avatar.scale.setScalar(THREE.MathUtils.clamp(baseScale * (dist/lastDist), 0.2, 3));
          avatar.rotation.y = baseRotY + (angle - lastAngle);
        }
      }
    } else {
      outline.visible = false;
      lastDist = undefined;
      fingersActive = 0;
    }
  }

  // keep outline synced
  outline.updateMatrixWorld(true);
  outline.update();

  renderer.render(scene, camera);
});

async function place(m, hitResult, frame){
  avatar.visible = true;

  // try anchor
  anchor = null;
  if (hitResult && hitResult.createAnchor) {
    try {
      anchor = await hitResult.createAnchor();
    } catch(e){
      console.warn('Anchor create failed', e);
    }
  }

  if (!anchor) {
    // fallback to matrix placement
    avatar.position.setFromMatrixPosition(m);
    const cam = renderer.xr.getCamera(camera);
    avatar.lookAt(new THREE.Vector3(cam.position.x, avatar.position.y, cam.position.z));
  } else {
    // set initial matrix from anchor immediately
    const ap = frame?.getPose(anchor.anchorSpace, localSpace);
    if (ap){
      avatar.matrix.fromArray(ap.transform.matrix);
      avatar.matrix.decompose(avatar.position, avatar.quaternion, avatar.scale);
    }
  }

  placed = true;
  reticle.visible = false;

  mixer.stopAllAction();
  currentAction = null;
  playNext();
}

// Reset button
document.getElementById('reset').addEventListener('click', ()=>{
  placed = false;
  avatar.visible = false;
  if (anchor?.delete) { try { anchor.delete(); } catch {} }
  anchor = null;
});

</script>
</body>
</html>

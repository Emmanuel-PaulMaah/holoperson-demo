<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR AR • RPM + Mixamo autoplay • artificial lighting</title>
  <link rel="icon" href="data:,">
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    .hint { position:fixed; left:12px; top:12px; color:#fff; font:14px/1.4 system-ui, sans-serif; }
  </style>
</head>
<body>
<div class="hint">Auto-place on first plane. Animations cycle. Fixed studio lighting (no room light).</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';

const AVATAR_URL = './assets/model_avatar.glb';
const ANIM_URLS = [
  './assets/Talking1.glb',
  './assets/Talking2.glb',
  './assets/Talking3.glb',
  './assets/Breathing_Idle.glb'
];

// renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.physicallyCorrectLights = true;
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight), { passive:true });

// scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera();

// --- Artificial lighting rig (three-point + IBL). No light estimation. ---
// Image-based lighting for PBR materials
const pmrem = new THREE.PMREMGenerator(renderer);
new RGBELoader()
  .setPath('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/hdri/')
  .load('venice_sunset_1k.hdr', (hdr)=>{
    const envMap = pmrem.fromEquirectangular(hdr).texture;
    scene.environment = envMap; // keeps AR passthrough since no background set
    hdr.dispose();
  });

// Key light (warm)
const key = new THREE.DirectionalLight(0xfff1df, 2.2);
key.position.set(1.5, 2.5, 0.8);
scene.add(key);

// Fill light (cooler, softer)
const fill = new THREE.DirectionalLight(0xdfe8ff, 0.8);
fill.position.set(-1.2, 1.8, 1.2);
scene.add(fill);

// Rim light (neutral, highlights silhouette)
const rim = new THREE.DirectionalLight(0xffffff, 1.4);
rim.position.set(-0.5, 2.8, -1.8);
scene.add(rim);

// Low ambient floor via hemisphere to keep undersides readable
const hemi = new THREE.HemisphereLight(0xffffff, 0x3a3a3a, 0.25);
scene.add(hemi);

// reticle
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.1,0.12,48).rotateX(-Math.PI/2),
  new THREE.MeshBasicMaterial({ color:0xff7a00 })
);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// AR button (no light-estimation requested)
document.body.appendChild(ARButton.createButton(renderer,{
  requiredFeatures:['hit-test'],
  optionalFeatures:['dom-overlay','anchors'],
  domOverlay:{ root: document.body }
}));

// loaders
const gltf = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
gltf.setDRACOLoader(draco);

// avatar + anims
let avatar, mixer, outline;
let clips=[];
let placed=false;

await gltf.loadAsync(AVATAR_URL).then(g=>{
  avatar=g.scene;
  scene.add(avatar);
  avatar.visible=false;

  // ensure materials respond to IBL and lights
  avatar.traverse((o)=>{
    if(o.isMesh){
      o.castShadow = false;
      o.receiveShadow = false;
      if(o.material){
        // keep as is; GLTF PBR will use scene.environment
        o.material.needsUpdate = true;
      }
    }
  });

  mixer=new THREE.AnimationMixer(avatar);
  mixer.addEventListener('finished', ()=> playNext()); // auto-cycle
  outline=new THREE.BoxHelper(avatar,0xff7a00);
  outline.visible=false;
  scene.add(outline);
});

await Promise.all(
  ANIM_URLS.map(u =>
    gltf.loadAsync(u).then(g=>{
      if(g.animations?.length) clips.push(g.animations[0]);
    })
  )
);

let currentAction=null;
function playNext(){
  if(!clips.length || !mixer) return;
  const clip = clips.shift(); clips.push(clip);
  const next = mixer.clipAction(clip);
  next.setLoop(THREE.LoopOnce, 1);
  next.clampWhenFinished = true;
  next.reset();
  if(currentAction){
    currentAction.crossFadeTo(next, 0.25, false);
    next.play();
  } else {
    next.fadeIn(0.25).play();
  }
  currentAction = next;
}

// XR vars
let viewerSpace, localSpace, planeSource, fingerSource;
let lastDist, lastAngle, baseScale=1, baseRotY=0;

renderer.xr.addEventListener('sessionstart',async()=>{
  const s=renderer.xr.getSession();
  viewerSpace=await s.requestReferenceSpace('viewer');
  localSpace=await s.requestReferenceSpace('local');
  planeSource=await s.requestHitTestSource({space:viewerSpace});
  fingerSource=await s.requestHitTestSourceForTransientInput({profile:'generic-touchscreen'});
});

renderer.xr.addEventListener('sessionend',()=>{
  viewerSpace=localSpace=planeSource=fingerSource=null;
  placed=false;
});

// loop
const clock=new THREE.Clock();
renderer.setAnimationLoop((_,frame)=>{
  const dt=clock.getDelta();
  mixer?.update(dt);

  // plane reticle
  if(frame && planeSource && !placed){
    const hits=frame.getHitTestResults(planeSource);
    if(hits.length){
      const pose=hits[0].getPose(localSpace);
      reticle.visible=true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else reticle.visible=false;
  }

  // gestures
  if(frame && fingerSource){
    const fingers=frame.getHitTestResultsForTransientInput(fingerSource);
    if(fingers.length){
      outline.visible=true;
      if(!placed && reticle.visible) place(reticle.matrix);
      if(placed){
        if(fingers.length===1 && fingers[0].results.length){
          const pose=fingers[0].results[0].getPose(localSpace);
          const m=new THREE.Matrix4().fromArray(pose.transform.matrix);
          const pos=new THREE.Vector3().setFromMatrixPosition(m);
          avatar.position.set(pos.x, avatar.position.y, pos.z);
        } else if(fingers.length===2 && fingers[0].results.length && fingers[1].results.length){
          const p1=new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(fingers[0].results[0].getPose(localSpace).transform.matrix));
          const p2=new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(fingers[1].results[0].getPose(localSpace).transform.matrix));
          const v1=new THREE.Vector2(p1.x,p1.z);
          const v2=new THREE.Vector2(p2.x,p2.z);
          const dist=v1.distanceTo(v2);
          const angle=Math.atan2(v2.y-v1.y,v2.x-v1.x);
          if(lastDist===undefined){lastDist=dist;lastAngle=angle;baseScale=avatar.scale.x;baseRotY=avatar.rotation.y;}
          const s=THREE.MathUtils.clamp(baseScale*(dist/lastDist),0.2,3);
          avatar.scale.setScalar(s);
          avatar.rotation.y=baseRotY+(angle-lastAngle);
        }
      }
    } else {outline.visible=false; lastDist=undefined;}
  }

  renderer.render(scene,camera);
});

// place on plane and start animation cycle
function place(m){
  avatar.visible=true;
  avatar.position.setFromMatrixPosition(m);
  const cam=renderer.xr.getCamera(camera);
  avatar.lookAt(new THREE.Vector3(cam.position.x,avatar.position.y,cam.position.z));
  placed=true;
  reticle.visible=false;
  playNext();
}
</script>
</body>
</html>
